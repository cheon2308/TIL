
[백준_2468 - 안전 영역](https://www.acmicpc.net/problem/2468)

#### **시간 제한 1초, 메모리 제한 128MB**

## **# 문제**

- 재난방재청에서는 많은 비가 내리는 장마철에 대비해서 다음과 같은 일을 계획하고 있다. 
- 먼저 어떤 지역의 높이 정보를 파악한다. 
- 그 다음에 그 지역에 많은 비가 내렸을 때 물에 잠기지 않는 안전한 영역이 최대로 몇 개가 만들어 지는 지를 조사하려고 한다. 
	- 이때, 문제를 간단하게 하기 위하여, 장마철에 내리는 비의 양에 따라 일정한 높이 이하의 모든 지점은 물에 잠긴다고 가정한다.
- 어떤 지역의 높이 정보는 행과 열의 크기가 각각 N인 2차원 배열 형태로 주어지며 배열의 각 원소는 해당 지점의 높이를 표시하는 자연수이다. 
	- 예를 들어, 다음은 N=5인 지역의 높이 정보이다.

|     |     |     |     |     |
| --- | --- | --- | --- | --- |
| 6   | 8   | 2   | 6   | 2   |
| 3   | 2   | 3   | 4   | 6   |
| 6   | 7   | 3   | 3   | 2   |
| 7   | 2   | 5   | 3   | 6   |
| 8   | 9   | 5   | 2   | 7   |

- 이제 위와 같은 지역에 많은 비가 내려서 높이가 4 이하인 모든 지점이 물에 잠겼다고 하자. 
- 이 경우에 물에 잠기는 지점을 회색으로 표시하면 다음과 같다.

![[assets/Pasted image 20240816114219.png]]

- 물에 잠기지 않는 안전한 영역이라 함은 물에 잠기지 않는 지점들이 위, 아래, 오른쪽 혹은 왼쪽으로 인접해 있으며 그 크기가 최대인 영역을 말한다. 
- 위의 경우에서 물에 잠기지 않는 안전한 영역은 5개가 된다(꼭짓점으로만 붙어 있는 두 지점은 인접하지 않는다고 취급한다).
- 또한 위와 같은 지역에서 높이가 6이하인 지점을 모두 잠기게 만드는 많은 비가 내리면 물에 잠기지 않는 안전한 영역은 아래 그림에서와 같이 네 개가 됨을 확인할 수 있다.
![[assets/Pasted image 20240816114311.png]]

- 이와 같이 장마철에 내리는 비의 양에 따라서 물에 잠기지 않는 안전한 영역의 개수는 다르게 된다. 
- 위의 예와 같은 지역에서 내리는 비의 양에 따른 모든 경우를 다 조사해 보면 물에 잠기지 않는 안전한 영역의 개수 중에서 최대인 경우는 5임을 알 수 있다.
- 어떤 지역의 높이 정보가 주어졌을 때, 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 계산하는 프로그램을 작성하시오.

#### **입력**
- 첫째 줄에는 어떤 지역을 나타내는 2차원 배열의 행과 열의 개수를 나타내는 수 N이 입력된다. 
- N은 2 이상 100 이하의 정수이다. 
- 둘째 줄부터 N개의 각 줄에는 2차원 배열의 첫 번째 행부터 N번째 행까지 순서대로 한 행씩 높이 정보가 입력된다. 
- 각 줄에는 각 행의 첫 번째 열부터 N번째 열까지 N개의 높이 정보를 나타내는 자연수가 빈 칸을 사이에 두고 입력된다. 
- 높이는 1이상 100 이하의 정수이다.

#### **출력**
- 첫째 줄에 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 출력한다.

## **# 접근 방법**

- 영역 나누기와 똑같은 문제이다
- 인접하지 않은 구역의 개수를 구하는 문제이므로 bfs로 탐색해주면 된다.
- 내리는 비의 높이에 따라 구역의 개수가 달라지므로 최초에 배열을 입력받을 때 높이의 최댓값을 구해주고 1부터 해당 높이까지 순회하면서 구해준다.
- result의 기본 값은 모든 영역이 잠기지 않은 경우 => 1로 설정해준다.

```python
import sys  
sys.stdin = open('input.txt')  
input = sys.stdin.readline  
from collections import deque  
  
di, dj = [0, -1, 0, 1], [-1, 0, 1, 0]  
  
  
  
def main():  
    def bfs(bi, bj):  
        q = deque()  
        q.append((bi, bj))  
        while q:  
            si, sj = q.popleft()  
            for d in range(4):  
                ni, nj = si + di[d], sj + dj[d]  
                if 0 <= ni < N and 0 <= nj < N and visited[ni][nj] == 0:  
                    q.append((ni, nj))  
                    visited[ni][nj] = 1  
  
    N = int(input())  
    max_height = 0  
    result = 1  
    arr = [list(map(int, input().split())) for _ in range(N)]  
  
    for i in range(N):  
        max_height = max(max_height, max(arr[i]))  
  
    for height in range(1, max_height):  
        visited = [[0 if arr[i][j] > height else 1 for i in range(N)] for j in range(N)]  
        temp_result = 0  
        for i in range(N):  
            for j in range(N):  
                if visited[i][j] == 0:  
                    temp_result += 1  
                    visited[i][j] = 1  
                    bfs(i, j)  
        result = max(result, temp_result)  
    print(result)  
  
main()
```

- 다른 분들의 풀이를 참고하니 union, find로 해결하는 경우 훨씬 빠른 속도로 solve를 받았음을 확인하였다.


