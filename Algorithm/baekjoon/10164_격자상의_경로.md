
[백준 10164 - 격자상의 경로](https://www.acmicpc.net/problem/10164)

#### **시간 제한 1초, 메모리 제한 256MB**

## **# 조건**

- 행의 수가 N이고 열의 수가 M인 격자의 각 칸에 1부터 N×M까지의 번호가 첫 행부터 시작하여 차례로 부여되어 있다. 
- 격자의 어떤 칸은 ○ 표시가 되어 있다. (단, 1번 칸과 N × M번 칸은 ○ 표시가 되어 있지 않다. 또한, ○ 표시가 되어 있는 칸은 최대 한 개이다. 즉, ○ 표시가 된 칸이 없을 수도 있다.) 
- 행의 수가 3이고 열의 수가 5인 격자에서 각 칸에 번호가 1부터 차례대로 부여된 예가 아래에 있다. 
	- 이 격자에서는 8번 칸에 ○ 표시가 되어 있다.

![](https://upload.acmicpc.net/8299a142-dd28-48bc-a698-64b8789e4733/-/preview/)

- 격자의 1번 칸에서 출발한 어떤 로봇이 아래의 두 조건을 만족하면서 N×M번 칸으로 가고자 한다. 
	- 조건 1: 로봇은 한 번에 오른쪽에 인접한 칸 또는 아래에 인접한 칸으로만 이동할 수 있다. (즉, 대각선 방향으로는 이동할 수 없다.)
	- 조건 2: 격자에 ○로 표시된 칸이 있는 경우엔 로봇은 그 칸을 반드시 지나가야 한다. 
- 위에서 보인 것과 같은 격자가 주어질 때, 로봇이 이동할 수 있는 서로 다른 경로의 두 가지 예가 아래에 있다.
	- 1 → 2 → 3 → 8 → 9 → 10 → 15
	- 1 → 2 → 3 → 8 → 13 → 14 → 15
- 격자에 관한 정보가 주어질 때 로봇이 앞에서 설명한 두 조건을 만족하면서 이동할 수 있는 서로 다른 경로가 총 몇 개나 되는지 찾는 프로그램을 작성하라.

## **# 접근 방법**

- bfs를 이용하여 푼다면 시간 초과로 subTask만 solve 할 수 있다.
- 따라서, dp를 이용하여 풀어준다.
- 움직일 수 있는 방법은 오른쪽, 또는 아래이므로 **현재 칸까지 올 수 있는 방법은 dp[i-1][j] + dp[i][j-1]** 의 값을 더한 것이다. 
- 이 때, K번째 칸을 거쳐가야 한다면, dp[k숫자의 행][k숫자의 열] * dp[N-Ki-1][M-Kj-1]을 곱해주면 된다.

```python
import sys  
sys.stdin = open('input.txt')  
input = sys.stdin.readline  
  
N, M, K = map(int, input().split())  
arr = [[0] * M for _ in range(N)]  
cnt = 1  
for i in range(N):  
    for j in range(M):  
        arr[i][j] = cnt  
        cnt += 1  
  
dp = [[0] * M for _ in range(N)]  
for i in range(M):  
    dp[0][i] = 1  
  
for j in range(N):  
    dp[j][0] = 1  
  
fi, fj = 0, 0  
if K > 1:  
    fi = (K-1)//M  
    fj = K%M - 1 if K%M != 0 else M-1  
for i in range(1, N):  
    for j in range(1, M):  
        dp[i][j] = dp[i-1][j] + dp[i][j-1]  
  
print(dp[fi][fj] * dp[N-fi-1][M-fj-1] if K else dp[N-1][M-1])
```