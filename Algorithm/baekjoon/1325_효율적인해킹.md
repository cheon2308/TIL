[백준 1325_효율적인해킹](https://www.acmicpc.net/problem/1325)

## 조건
- 회사는 N개의 컴퓨터로 이루어져 있고 한 번의 해킹으로 여러 개의 컴퓨터를 해킹하는 것이 목표
- 신뢰 관계, 신뢰x 관계로 이루어져 있는데 만약 A가 B를 신뢰한다면 B를 해킹하면, A도 해킹가능
- 신뢰하는 관계가 주어졌을 때, 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호 출력


## 접근 방법 및 어려운 점
- 서로 얽혀있기 때문에 bfs를 통하여 접근하였다.
- 계속 메모리 초과가 났는데 아래 코드와 다른 점은 신뢰관계를 전체 컴퓨터 2중리스트에 기록해주었다.

```python
import sys  
from collections import deque  
input = sys.stdin.readline  
  
n,m = map(int,input().split())  
  
def bfs(start):  
   cnt = 1  
    # 시작 위치 받아준 후 deque에 넣어준다.
   queue = deque([start])  
   # 방문 리스트
   visit = [False for _ in range(n+1)]  
   visit[start] = True  
  
   while queue:  
      cur = queue.popleft()  
	  # 신뢰관계를 순회하며
      for nx in graph[cur]:  
	      # 아직 방문하지 않았다면 방문 표시 남겨준 후 +1
         if not visit[nx]:  
            visit[nx] = True  
            cnt += 1  
            # 다음 방문 위치 que에 기록
            queue.append(nx)  
  
   return cnt  
  
graph = [[] for _ in range(n+1)]  
  
for _ in range(m):  
    # 신뢰 관계를 기록해주는데 뒷번호의 인덱스에 앞번호를 넣어준다.
    a,b = map(int,input().split())  
    graph[b].append(a)  
  
maxCnt = 1  
ans = []  
  
for i in range(1,n+1):  
	# bfs를 통하여 시작위치에 따른 최댓값을 구해서 비교해준다.
   cnt = bfs(i)  
   if cnt > maxCnt:  
      maxCnt = cnt  
      ans.clear()  
      ans.append(i)  
   elif cnt == maxCnt:  
      ans.append(i)  
  
print(*ans)
```