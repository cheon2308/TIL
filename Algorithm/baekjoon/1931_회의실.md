[백준 1931_회의실 배정](https://www.acmicpc.net/problem/1931)

```python
import sys
sys.stdin = open ('input.txt')

# 1931_회의실 배정

# N개의 회의에 대해 회의실 사용표를 만든다.
# 각 회의 I에 대해 시작 시간과 끝나는 시간이 있고 회의가 겹치지 않으며 사용할 수 있는 최대 개수
# 회의는 중간에 중단 불가하고 회의의 시작 시간과 끝나는 시간이 같을 수 있다.

# 전체 회의 수
T = int(input())
meet = [list(map(int, sys.stdin.readline().split())) for _ in range(T)]

# 회의시간 끝나는 시간 기준으로 정렬
# 시작시간으로 브루트포스를 이용하여야 되서 시간초과가 난다.
# 회의 시작시간 = 끝나는 시간인 회의가 있을 수 있으므로 시작시간 오름차순 후 끝나는 시간 오름 차순 정렬해줘야 함
meet.sort(key= lambda x: x[0])
meet.sort(key= lambda x: x[1])

# 회의수 저장, 첫 회의가 포함되어 있기 때문에 1
cnt = 1
# 기준이 되는 회의 종료 시간 저장
end_meet = meet[0]
# 다음 회의부터 시작해서 비교한다.
for i in range(1, len(meet)):
    if meet[i][0] >= end_meet[1]:
        cnt+=1
        end_meet = meet[i]

print(cnt)







# # 2. 틀렸습니다.
# # 회의시간 끝나는 시간 기준으로 정렬
# # 시작시간으로 브루트포스를 이용하여야 되서 시간초과가 난다.
# meet.sort(key= lambda x: x[1])
#
# # 회의수 저장
# cnt = 1
# # 기준이 되는 회의 종료 시간 저장
# end_meet = meet[0][1]
# for i in range(len(meet)):
#     if meet[i][0] >= end_meet:
#         cnt+=1
#         end_meet = meet[i][1]
#
# print(cnt)





# # 1. 시간초과
#
# # 겹치는 시간에서 회의 시간이 짧을 수록 더 많은 회의가 진행될 수 있다.
# # 회의시간이 짧은 애부터 돌아가며 길이를 저장 후 비교한다.
# # 전체 회의 수 저장
#
# max_cnt = 0
#
#
#
# for i in range(len(meet)):
#     # 끝나는 회의 저장 해두고 비교 기준으로 사용
#     end_meet = meet[i]
#     # 회의 개수 초기값 1로 저장
#     cnt = 1
#     if end_meet[1] <= meet[i][0]:
#         break
#
#     for k in range(i+1, len(meet)):
#         # 회의 끝나는 시간과 시작하는 시간이 같거나 크다면
#         if end_meet[1] == meet[k][0] or end_meet[1] < meet[k][0]:
#             cnt += 1
#             # 끝나는 회의 바꿔주기
#             end_meet = meet[k]
#
#         # 회의 개수가 이전 값보다 크다면 새로 저장
#         if cnt > max_cnt:
#             max_cnt = cnt
#
# print(max_cnt)
```
