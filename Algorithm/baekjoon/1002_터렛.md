[백준 1002_터렛](https://www.acmicpc.net/problem/1002)


## 조건
- 규현과 승환의 좌표 -10,000 <= (x1, y1), (x2, y2) <= 10,000
- 규현이 계산한 재명과의 거리 r1 <= 10,000
- 승환이 계산한 재명과의 거리 r2 <= 10,000
- 재명이 있을 수 있는 좌표의 수를 출력하는데 위치의 개수가 무한대일 경우 -1



## 접근 방법
- 거리 공식 = c^2 = (x1 -x2)^2 + (y1-y2)^2
- 따라서, 각 r1과 r2의 거리에 올 수 있는, x와 y좌표의 범위를 구해준다.
- 각 좌표의 범위를 그려보면 규현과 승환의 위치를 중심으로 하는 원이 나오고 반지름이 r1과 r2일 때 두 원의 교점의 개수를 구하는 문제이다.
- 두 원이 겹친다면 -1,
- 만나지 않으면 0
- 내접 또는 외접이라면 1
- 두 점에서 만난다면 2


#### **중심거리와 두 원의 위치 관계** 공식
- 반지름의 길이가 r1인 원과 r2인 원의 중심거리를 d
- abs(r1-r2) 또는 r1+r2 크기를 비교
	- r1 + r2 < d 이면 두 원은 서로의 외부에 위치
	- r1 + r2 = d 이면 외접
	- abs(r1-r2) < d < r1 + r2 이면 두 원은 서로 다른 두 점에서 만난다.
	- abs(r1-r2) = d 이면 한 원이 다른 원에 내접
	- abs(r1-r2) > d, r1 != r2이면 한 원이 다른 원의 내부에 존재
	- r1 == r2 이고 d = 0라면 동일한 원


```python
T = int(input())  
for tc in range(T):  
    x1, y1, r1, x2, y2, r2 = map(int, input().split())  
  
    # 두 원의 교점 개수 구하는 문제이다.  
    # 중심거리와 두 원의 위치 관계 공식 이용  
    # 중심 거리    
    dist = ((x1-x2)**2 + (y1-y2)**2)**0.5  
  
    # 원이 겹친다면 무한히 많은 곳에 존재  
    if dist == 0 and r1 == r2:  
        print(-1)  
    # 내접, 외접 이라면 -> 한 점에서 만난다면  
    elif dist == r1+r2 or dist == abs(r1-r2):  
        print(1)  
    # 반지름을 빼준 것과 더해준 것 가운데 위치한다면 두 점에서 만난다.  
    elif abs(r1-r2) < dist < r1+r2:  
        print(2)  
  
    else:  
        print(0)
```
