
- 다시 풀어보기

## 조건 

- 무인도에 갖힌 나삼성씨는, SOS 신호를 보낸다.
- N개의 직육면체 모양 상자들을 아래 그림과 같이 탑처럼 쌓아 올려 눈에 잘 보이게 하려고 한다. 
 
![](assets/Pasted%20image%2020221205164109.png)

- 규칙
	- 각각의 상자는 가로, 세로, 높이 축을 기준으로 90도씩 회전시켜 쌓을 수 있다.
	- N개의 상자를 쌓는 순서에는 별다른 제약이 없으며, 모든 상자를 다 사용하지 않아도 된다.
	- 모든 상자의 밑면은, 바로 아래 쌓여진 상자의 윗면을 벗어나선 안된다.
- 입력으로 N개의 상자들의 가로, 세로, 높이의 길이가 각각 주어질 때, 쌓을 수 있는 최대 높이를 계산하라.



## 접근 방법

- 단순히 상자를 많이 쌓는 것이 아닌, 최대 높이를 구하여야 된다.
- 다른 상자 위에 쌓기 위해서는 가로, 세로, 높이 중 2개가 작거나 같아야 한다.
- 밑면이 될 수 있는 경우의 수는 3가지이다.
	- 가로 x 세로
	- 세로 x 높이
	- 가로 x 높이
- 따라서, 3가지의 경우를 모두 리스트에 더해준다.
- 이 때, 같은 박스를 구분하기 위하여 박스 번호를 같이 넣어준다.
- 주어지는 가로 세로 높이를 밑면으로 했을 때를 기준으로 모든 박스를 오름차순 정렬해준 후 남은 높이를 따로 저장해준다.
- 반복문을 box의 개수 x 3번을 돌며, 현재 박스에서 0번인덱스의 박스 = 제일 밑면이 좁은 박스를 순회한다.
- 현재 박스와 아래 쌓인 박스의 높이가, 리스트에 기록해놓은 박스의 높이보다 높다면 갱신해준다.

```python
import sys  
sys.stdin = open('input.txt')  
  
T = int(input())  
for test_case in range(1, T + 1):  
    box_num = int(input())  
    boxs = []  
    for i in range(box_num):  
        box = list(map(int, input().split()))  
        boxs.append([box[0], box[1], box[2], i])  
        boxs.append([box[1], box[2], box[0], i])  
        boxs.append([box[2], box[0], box[1], i])  
  
    boxs = sorted(boxs, key=lambda x: x[0] * x[1])  
  
    db = [box[2] for box in boxs]  
    db_list = [[boxs[i][3]] for i in range(box_num * 3)]  
  
    for i in range(box_num * 3):  
        for j in range(i, -1, -1):  
            if i == j:  
                continue  
            if boxs[i][3] in db_list[j]:  
                continue  
            if (boxs[i][0] >= boxs[j][0] and boxs[i][1] >= boxs[j][1]) or (  
                    boxs[i][0] >= boxs[j][1] and boxs[i][1] >= boxs[j][0]):  
                if db[j] + boxs[i][2] > db[i]:  
                    db[i] = db[j] + boxs[i][2]  
                    db_list[i] = db_list[j] + [boxs[i][3]]  
    print("#" + str(test_case) + " " + str(max(db)))
```