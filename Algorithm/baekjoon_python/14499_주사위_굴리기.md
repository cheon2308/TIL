
[백준 14499_주사위 굴리기](https://www.acmicpc.net/problem/14499)


#### 시간 제한 2초, 메모리 제한 512MB


## 조건

- 크기가 N×M인 지도가 존재한다. 
- 지도의 오른쪽은 동쪽, 위쪽은 북쪽이다. 
- 이 지도의 위에 주사위가 하나 놓여져 있으며, 주사위의 전개도는 아래와 같다. 
- 지도의 좌표는 (r, c)로 나타내며, r는 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다.

```
  2
4 1 3
  5
  6
```

- 주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며, 놓여져 있는 곳의 좌표는 (x, y) 이다. 
- 가장 처음에 주사위에는 모든 면에 0이 적혀져 있다.
- 지도의 각 칸에는 정수가 하나씩 쓰여져 있다. 
- 주사위를 굴렸을 때, 이동한 칸에 쓰여 있는 수가 0이면, 주사위의 바닥면에 쓰여 있는 수가 칸에 복사된다. 
- 0이 아닌 경우에는 칸에 쓰여 있는 수가 주사위의 바닥면으로 복사되며, 칸에 쓰여 있는 수는 0이 된다.
- 주사위를 놓은 곳의 좌표와 이동시키는 명령이 주어졌을 때, 주사위가 이동했을 때 마다 상단에 쓰여 있는 값을 구하는 프로그램을 작성하시오.
- 주사위는 지도의 바깥으로 이동시킬 수 없다.
- 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.


#### 입력

- 첫째 줄에 지도의 세로 크기 N, 가로 크기 M (1 ≤ N, M ≤ 20), 주사위를 놓은 곳의 좌표 x, y(0 ≤ x ≤ N-1, 0 ≤ y ≤ M-1), 그리고 명령의 개수 K (1 ≤ K ≤ 1,000)가 주어진다.
- 둘째 줄부터 N개의 줄에 지도에 쓰여 있는 수가 북쪽부터 남쪽으로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 
- 주사위를 놓은 칸에 쓰여 있는 수는 항상 0이다. 
- 지도의 각 칸에 쓰여 있는 수는 10 미만의 자연수 또는 0이다.
- 마지막 줄에는 이동하는 명령이 순서대로 주어진다. 
- 동쪽은 1, 서쪽은 2, 북쪽은 3, 남쪽은 4로 주어진다.



## 접근 방법

- 처음 주사위의 모든 면은 0으로 초기화 되어있다.
- 여섯 면이므로 DICE 배열에 0번 인덱스부터 윗면, 아랫면, 동 서 남 북으로 저장해준다.
- 이후 주사위를 굴리는데 굴리는 방향에 따른 규칙은
	- 윗면은 굴린방향, 아랫면은 굴린방향의 반대방향
	- 굴린 방향은 아랫면, 굴린 반대 방향은 윗면
	- 상관없은 나머지 두 면은 그대로
 - 동쪽으로 굴린다고 가정할 경우
	- 윗면은 동쪽, 아랫면은 반대방향인 서쪽
	- 동쪽은 아랫면, 반대인 서쪽은 윗면
	- 남쪽과 북쪽은 그대로
- 굴린 후 방향을 바꿔줘야 하므로 deepcopy를 이용하여 원본을 저장해준다.
- 따라서 굴리는 방향에 따라 주사위 배열의 값을 변경해주며 윗면 즉 DICE[0]를 출력해준다.


```python
import sys  
sys.stdin = open('input.txt')  
input = sys.stdin.readline  
from copy import deepcopy  
N, M, initDice_i, initDice_j, C = map(int, input().split())  
  
arr = []  
for i in range(N):  
    a = [*map(int, input().split())]  
    arr.append(a)  
  
command = [*map(int, input().split())]  
  
dice = [0] * 6  
  
di, dj = [0, 0,0,-1,1], [0, 1,-1,0,0]  
  
for j in command:  
    ni, nj = initDice_i + di[j], initDice_j + dj[j]  
    dice2 = deepcopy(dice)  
    if 0<=ni<N and 0<=nj<M:  
        # 주사위 굴리는 방향에 따른 변화 deepcopy  
        # 동서남북 순        
        if j == 1:  
            dice[0], dice[1], dice[2], dice[3] = dice2[2], dice2[3], dice2[1], dice2[0]  
        elif j == 2:  
            dice[0], dice[1], dice[2], dice[3] = dice2[3], dice2[2], dice2[0], dice2[1]  
        elif j == 3:  
            dice[0], dice[1], dice[4], dice[5] = dice2[4], dice2[5], dice2[1], dice2[0]  
        else:  
            dice[0], dice[1], dice[4], dice[5] = dice2[5], dice2[4], dice2[0], dice2[1]  
  
        if arr[ni][nj] == 0:  
            arr[ni][nj] = dice[1]  
        else:  
            dice[1] = arr[ni][nj]  
            arr[ni][nj] = 0  
        print(dice[0])  
        initDice_i, initDice_j = ni, nj  
    else:  
        continue

```