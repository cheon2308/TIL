
[백준 21922 - 학부 연구생 민상](https://www.acmicpc.net/problem/21922)

#### **시간 제한 1초, 메모리 제한 512MB**

## **# 조건**

- 학부 연구생으로 새로 연구실에 들어온 민상이는 사용할 자리를 정하려고 한다.
- 연구실은 격자 모양으로 되어있고 에어컨에서 바람이 상,하,좌,우 4$4$방향으로 분다. 
	- 물론 에어컨이 위치한 곳에도 바람이 분다.
- 민상이는 더위를 많이 타서 에어컨 바람이 지나가는 곳 중 하나를 선택하여 앉으려고 한다.
- 연구실에는 다양한 물건들이 있어 바람의 방향을 바꾼다.
- 연구실에 있는 물건의 종류는 총 4가지가 있다. 
	- 아래 화살표의 의미는 바람이 각 물건에서 바람의 이동을 표시한 것이다.

![](assets/Pasted%20image%2020230820121751.png)

- 연구실 어디든 민상이가 앉을 수 있는 자리이다. 
	- 즉 에어컨이 위치한 자리와 물건이 있는 자리 모두 앉을 수 있다.
- 민상이가 원하는 자리는 몇 개 있는지 계산해주자.

#### **입력**
- 첫 번째 줄에는 연구실의 크기가 세로 $N(1 \le N \le 2,000)$, 가로 $M(1 \le M \le 2,000)$ 순으로 주어진다.
- 두 번째 줄부터 $N + 1$ 줄까지 연구실 내부 구조 정보를 알려주는 값 $M$개가 주어진다.
- $1,2,3,4$는 위에서 설명한 물건의 종류이다.
- 9는 에어컨을 의미하고, $0$은 빈 공간을 의미한다.
- 에어컨은 $0$개 이상 $50$개 이하가 들어온다.

#### **출력**
- 민상이가 원하는 자리의 개수를 출력한다.


## **# 접근 방법**

- 주어지는 연구실의 정보를 받고 순회하며 우선 에어컨의 위치를 큐에 담아준다.
- 또한 벽을 만났을 때는 방향 전환을 해주어야 하기 때문에 방향 전환용 딕셔너리를 만들어준다.
- 델타 함수의 경우 상좌하우 순으로 탐색하게 만들어 준다.
	- 1과 2의 경우 좌우, 상하 반전이므로 따로 탐색해주지 않아도 된다.
	- 3의 경우
		- 위로 향하다가 만나면 오른쪽
		- 아래로 향하다가 만나면 왼쪽
		- 따라서 [3, 1, -1, -3] 과 같이 만들어 준다.
	- 4도 마찬가지로
		- [1, -1, 1, -1]
	- 위의 리스트는 각 방향이 만났을 때, 델타 함수에 더해줘야 하는 값이다.
- 저장해둔 에어컨 리스트를 돌며 bfs를 돌린다.
- 첫 시작은 4방향 모두 체크해주어야 하기 때문에 각 방향마다 bfs를 따로 돌려준다.
	- q에는 다음 좌표 + 이동하던 방향을 넣어주고
	- 물건을 만났을 때는 walls[물건번호][현재 방향]을 통하여 d를 변경해주고 방향 전환을 해준다.

```python

```python
from collections import deque
import sys

si = sys.stdin.readline

n, m = map(int, si().split())
visited = [[0] * m for _ in range(n)]


queue = deque()

graph = []
for i in range(n):
    line = list(map(int, si().split()))
    for j in range(m):
        if line[j] == 9:
            queue.append((i, j))
            visited[i][j] = 1
    graph.append(line)


def bfs(g, q):
    xd = [-1, 1, 0, 0]
    yd = [0, 0, -1, 1]
    while q:
        x, y = q.popleft()
        for idx in range(4):
            nx, ny = xd[idx], yd[idx]
            r, c = x + nx, y + ny
            while 0 <= r < n and 0 <= c < m:
                visited[r][c] = 1
                if g[r][c] == 9:
                    break
                if g[r][c] == 3:
                    nx, ny = -ny, -nx
                elif g[r][c] == 4:
                    nx, ny = ny, nx
                elif (g[r][c] == 1 and nx == 0) or (g[r][c] == 2 and ny == 0):
                    break
                r += nx
                c += ny
    answer = 0
    for ans in visited:
        answer += ans.count(1)
    return answer


print(bfs(graph, queue))
```
```
