
[백준 28099 - 이상한 배열](https://www.acmicpc.net/problem/28099)

#### **시간 제한 1초, 메모리 제한 1024MB**

## **# 조건**

- 길이가 N인 배열 A가 주어진다.
- 배열 A가 아래 조건을 만족한다면 이 배열 A를 **이상한 배열**이라 한다.
- Ai = Aj를 만족하는 정수 1 <= i, j <= N와 i < k < j를 만족하는 정수 k에 대해, 항상 Ak <= Ai를 만족한다.
- 배열 A가 주어질 때 A가 이상한 배열인지 확인해라.


#### **입력**
- 첫 줄에 테스트케이스의 수 T가 주어진다 (1 <= T <= 200,000)
- 각 테스트케이스에 대해, 첫 번째 줄에 배열의 길이 N이 주어진다. (1<=N<=200,000)
- 두 번째 줄에는 배열의 원소를 나타내는 N개의 정수 A1, A2, .... , AN이 공백으로 구분되어 주어진다. (1<=Ai<=N)
- 모든 테스트 케이스에 대해 N의 합이 200,000이하임이 보장된다.


#### **출력**
- 각 테스트케이스에 대해 주어진 배열이 이상한 배열이면 Yes, 아니라면 No를 출력한다.


## **# 접근 방법**

#### `처음 아이디어`

- 우선 입력받은 배열에 중복되는 숫자가 없다면, 이상한 배열에도 포함된다.
	- 주어진 테스트 케이스의 1번이 위와 같은 경우여서 이해하는데 시간이 조금 걸렸다.
- nums 딕셔너리를 만들어주고 value값은 리스트로 설정해준다.
- 이후 주어진 배열을 순회하며 각 숫자가 위치한 인덱스 번호를 nums 딕셔너리에 넣어준다.
- 이후, nums의 숫자들을 하나씩 순회할 건데
	- 만약 길이가 1이라면 continue 해준다.
	- 1보다 크다면 nums[i][0] 부터 nums[i][-1] 까지 순회하며 현재 i보다 arr[k]가 작거나 같은지 검사해준다.
	- 만약 하나라도 크다면 No를 출력해주고 break
- 출력 형식도 잘 읽어보자.. YES로 했다가 3%에서 계속 틀렸다.
- 현재 풀이 같은 경우 73%에서 시간 초과가 발생한다. 조금 더 줄일 수 있는 방법을 찾아야 할 것 같다.

```PYTHON

import sys  
sys.stdin = open('input.txt')  
input = sys.stdin.readline  
from collections import defaultdict  
  
  
T = int(input())  
for _ in range(T):  
    N = int(input())  
    arr = [*map(int, input().split())]  
    nums = defaultdict(list)  
    for idx, val in enumerate(arr):  
        nums[val].append(idx)  
  
    result = 'Yes'  
    for i in nums:  
        flag = True  
        if len(nums[i]) == 1:  
            continue  
        for k in range(nums[i][0]+1, nums[i][-1]):  
            if arr[k] > i:  
                print('No')  
                flag = False  
                break  
        if not flag:  
            break  
  
    else:  
        print(result)
```


-