
[백준 28099 - 이상한 배열](https://www.acmicpc.net/problem/28099)

#### **시간 제한 1초, 메모리 제한 1024MB**

## **# 조건**

- 길이가 N인 배열 A가 주어진다.
- 배열 A가 아래 조건을 만족한다면 이 배열 A를 **이상한 배열**이라 한다.
- Ai = Aj를 만족하는 정수 1 <= i, j <= N와 i < k < j를 만족하는 정수 k에 대해, 항상 Ak <= Ai를 만족한다.
- 배열 A가 주어질 때 A가 이상한 배열인지 확인해라.


#### **입력**
- 첫 줄에 테스트케이스의 수 T가 주어진다 (1 <= T <= 200,000)
- 각 테스트케이스에 대해, 첫 번째 줄에 배열의 길이 N이 주어진다. (1<=N<=200,000)
- 두 번째 줄에는 배열의 원소를 나타내는 N개의 정수 A1, A2, .... , AN이 공백으로 구분되어 주어진다. (1<=Ai<=N)
- 모든 테스트 케이스에 대해 N의 합이 200,000이하임이 보장된다.


#### **출력**
- 각 테스트케이스에 대해 주어진 배열이 이상한 배열이면 Yes, 아니라면 No를 출력한다.


## **# 접근 방법**

#### `처음 아이디어`

- 우선 입력받은 배열에 중복되는 숫자가 없다면, 이상한 배열에도 포함된다.
	- 주어진 테스트 케이스의 1번이 위와 같은 경우여서 이해하는데 시간이 조금 걸렸다.
- nums 딕셔너리를 만들어주고 value값은 리스트로 설정해준다.
- 이후 주어진 배열을 순회하며 각 숫자가 위치한 인덱스 번호를 nums 딕셔너리에 넣어준다.
- 이후, nums의 숫자들을 하나씩 순회할 건데
	- 만약 길이가 1이라면 continue 해준다.
	- 1보다 크다면 nums[i][0] 부터 nums[i][-1] 까지 순회하며 현재 i보다 arr[k]가 작거나 같은지 검사해준다.
	- 만약 하나라도 크다면 No를 출력해주고 break
- 출력 형식도 잘 읽어보자.. YES로 했다가 3%에서 계속 틀렸다.
- 현재 풀이 같은 경우 73%에서 시간 초과가 발생한다. 조금 더 줄일 수 있는 방법을 찾아야 할 것 같다.

```PYTHON

import sys  
sys.stdin = open('input.txt')  
input = sys.stdin.readline  
from collections import defaultdict  
  
  
T = int(input())  
for _ in range(T):  
    N = int(input())  
    arr = [*map(int, input().split())]  
    nums = defaultdict(list)  
    for idx, val in enumerate(arr):  
        nums[val].append(idx)  
  
    result = 'Yes'  
    for i in nums:  
        flag = True  
        if len(nums[i]) == 1:  
            continue  
        for k in range(nums[i][0]+1, nums[i][-1]):  
            if arr[k] > i:  
                print('No')  
                flag = False  
                break  
        if not flag:  
            break  
  
    else:  
        print(result)
```


- 아래 범위 내를 탐색하는 부분을 set을 이용하여 변경해주었다.
- 해당 숫자가 처음 등장하는 인덱스라면 set에 add 해주고, 마지막 인덱스라면 set에서 remove해주었는데
	- 이 때, 순회하는 인덱스의 숫자는 set 안에 있는 최소 숫자보다 작아야한다는 조건을 걸어주었다.
	- C++에서는 정렬되는 set이 있어 set 내부의 최소값을 찾는 것이 빠르지만 python에서는 min을 이용해주어야 해서 여전히 시간초과가 발생했다.

```python
import sys
input = sys.stdin.readline

def main():
    T = int(input())
    for _ in range(T):
        N = int(input())
        arr = [*map(int, input().split())]
        nums = dict()
        for idx, val in enumerate(arr):
            if val in nums:
                nums[val][1] = idx
            else:
                nums[val] = [idx, -1]

        result = 'Yes'
        check = set()
        for idx, val in enumerate(arr):
            if check and val > min(check):
                result = 'No'
                break
            if nums[val][1] == -1:
                continue
            if not val in check:
                check.add(val)
            elif idx == nums[val][1]:
                check.remove(val)



        print(result)

if __name__ == '__main__':
    main()
```