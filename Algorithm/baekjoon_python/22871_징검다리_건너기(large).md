
[백준 22871 - 징검다리 건너기(large)](https://www.acmicpc.net/problem/22871)

#### **시간 제한 2초, 메모리 제한 1024MB**

## **# 조건**

- N개의 돌이 일렬로 나열 되어 있다.
- N개의 돌에는 왼쪽부터 차례대로 수 A1, A2, A3...Ai, An로 부여되어 있다.
- 가장 왼쪽에 있는 돌에서 출발하여 가장 오른쪽에 있는 돌로 건너가려고 한다.
	- 항상 오른쪽으로만 이동할 수 있다.
	- i번째 돌에서 j(i<j)번째 돌로 이동할 때 (j-i) * (1+abs(Ai-Aj))만큼 힘을 쓴다.
	- 돌을 한번 건너갈 때마다 쓸 수 있는 힘은 최대 K이다.
- 가장 왼쪽 돌에서 출발하여 가장 오른쪽에 있는 돌로 건너갈 수 있는 모든 경우 중 K의 최솟값을 구해보자.

#### **입력**
- 첫 번째 줄에 돌의 개수 N이 공백으로 구분되어 주어진다.
- 두 번째 줄에는 N개의 돌의 수 Ai가 공백으로 구분되어 주어진다.

#### **출력**
- 가장 왼쪽 돌에서 출발하여 가장 오른쪽에 있는 돌로 건너갈 수 있는 모든 경우 중 가능한 K의 최솟값을 출력한다.

## **# 접근 방법**

- 이전의 크기가 작은 문제들을 활용하여 최적의 해를 구할 수 있으므로 DP를 사용하여 풀어준다.
- 이 때 주의할 점은, **마지막 돌까지 이동하며 누적되는 최소의 힘**이 아닌 **각 돌을 지나면서 사용한 힘 중 최댓값의 최솟값을** 구하는 것이다.
	- 즉, K의 상한선을 낮추는 것이 문제의 핵심이다.
- 따라서 dp의 값은 아래의 로직을 따른다.
	- 0번 돌의 경우 건너가기 위한 힘이 0이므로 초기화 해준다.
	- 2중 반복문을 돌리는데 **1~N, 0~i**까지를 범위로 설정해준다.
	- val은 **j번 돌에서 i번 돌로 이동하는데 필요한 힘**과 **j번 돌에 기록된 값** 중 **큰 값**을 기록해준다.
		- 이 부분이 처음에 생각못하였는데, 2번 -> 4번으로 이동한다 가정할 때 이미 2번까지 3의 힘을 사용했다면, 2번 -> 4번으로 2의 힘만 필요하더라도 우리가 구해야 하는 값은 3이기 때문에 max로 구해주었다.
	- 이후, dp[i]의 값은 그 값들 중 최소로 갱신해주면 된다.
- 다만 아직도 시간 복잡도는 O(N^2)에 가까워서 그런지 pypy로만 통과된다. 


```python
import sys  
input = sys.stdin.readline  
  
N = int(input())  
nums = list(map(int, input().split()))  
dp = [float('inf') for _ in range(N)]  
dp[0] = 0  
for i in range(1, N):  
    for j in range(i):  
        val = max((i-j) * (1+abs(nums[j] - nums[i])), dp[j])  
        dp[i] = min(dp[i], val)  
print(dp[-1])
```