
[백준 22871 - 징검다리 건너기(large)](https://www.acmicpc.net/problem/22871)

#### **시간 제한 2초, 메모리 제한 1024MB**

## **# 조건**

- N개의 돌이 일렬로 나열 되어 있다.
- N개의 돌에는 왼쪽부터 차례대로 수 A1, A2, A3...Ai, An로 부여되어 있다.
- 가장 왼쪽에 있는 돌에서 출발하여 가장 오른쪽에 있는 돌로 건너가려고 한다.
	- 항상 오른쪽으로만 이동할 수 있다.
	- i번째 돌에서 j(i<j)번째 돌로 이동할 때 (j-i) * (1+abs(Ai-Aj))만큼 힘을 쓴다.
	- 돌을 한번 건너갈 때마다 쓸 수 있는 힘은 최대 K이다.
- 가장 왼쪽 돌에서 출발하여 가장 오른쪽에 있는 돌로 건너갈 수 있는 모든 경우 중 K의 최솟값을 구해보자.

#### **입력**
- 첫 번째 줄에 돌의 개수 N이 공백으로 구분되어 주어진다.
- 두 번째 줄에는 N개의 돌의 수 Ai가 공백으로 구분되어 주어진다.

#### **출력**
- 가장 왼쪽 돌에서 출발하여 가장 오른쪽에 있는 돌로 건너갈 수 있는 모든 경우 중 가능한 K의 최솟값을 출력한다.

## **# 접근 방법**

- 이전의 크기가 작은 문제들을 활용하여 최적의 해를 구할 수 있으므로 DP를 사용하여 풀어준다.
- 이 때 주의할 점은, **마지막 돌까지 이동하며 누적되는 최소의 힘**이 아닌 **각 돌을 지나면서 사용한 힘 중 최댓값의 최솟값을** 구하는 것이다.


```python
import sys  
input = sys.stdin.readline  
  
N = int(input())  
nums = list(map(int, input().split()))  
dp = [float('inf') for _ in range(N)]  
dp[0] = 0  
for i in range(1, N):  
    for j in range(i):  
        val = max((i-j) * (1+abs(nums[j] - nums[i])), dp[j])  
        dp[i] = min(dp[i], val)  
print(dp[-1])
```