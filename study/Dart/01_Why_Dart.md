

## 개요

- 구글이 2011년 **멀티 플랫폼 상에서 동작**되도록하는 앱을 위해 디자인된 프로그래밍 언어
- 기본적으로 c언어의 문법과 거의 같고
- Java, C#, Javascript와 같은 기능적 스트럭처를 추가한 언어
- 모바일, 데스크톱, 서버, 웹 앱 용도에 사용
- DVM 상에서 동작하거나 네이티브 컴파일링을 통해 모바일, 데스크톱, 웹 브라우저, 서버 플랫폼 상에서 어플리케이션 실행을 지원

> 공식 IDE

- 안드로이드 스튜디오
- IntelliJ IDEA
- VS Code 등..


> 초기 외면받은 이유

1. js를 대체하기 위해서라면 TypeScript 등의 다른 언어를 사용 가능
2. Dart는 언어적 특성이 그렇게 세련되어 보이지 않았고 러닝 커브가 높았음
3. Dart 만으로 이루어진 구현체가 마땅히 없었음
4. 웹 브라우저에서 바로 Dart가 동작하는 것도 아니었기 때문에 굳이 배울 필요가 없었지만

### -> Flutter에서 선택 받은 뒤로 많은 주목


## # 특징


> Flutter를 위한 언어

- Flutter를 위해 dart 언어를 수정할 수 있음
	- 다른 django, react 등 다른 곳에서는 불가능함
	- 초기에는 natvie 바이너리를 지원하는 ahead-of-time 툴체인이 없었음
	- dart 팀이 flutter를 위해 만들어준 것


> 컴파일러

2개의 컴파일러

#### 1. Dart Natvie

- dart 코드를 여러 CPU의 아키텍쳐에 맞게 변환
- ARM 32, 64, DESKTOP, ANDROID, IOS ....
- 더 작은 전력의 아키텍쳐로도 가능
	
#### 2. Dart Web

- dart로 쓴 코드를 javascript로 변환해주는 컴파일러


> 컴파일

#### 1. AOT (ahead-of-time)

- 익숙한 컴파일 방법
- **컴파일을 먼저하고, 그 결과인 바이너리를 배포**하는 방법
- 바이너리는 Cpu가 이해할 수 있는 기계어와 같은 것들
- 개발주기가 느리다
- 예시
	- C, C++, Rust, Go로 코딩한다고 하면 코딩이 끝나고 컴파일 할 때 아키텍처를 지정해주어야 한다.
	- C++ 코딩이 끝났을 때 Window 바이너리로 컴파일 해주고, 그 바이너리를 제공
	- 바이너리는 그냥 기계어


#### 2. JIT(just-in-time)

- 한 아키텍쳐를 위해 컴파일 한다는 것은 아주 많은 최적화를 하고 기계어로 만들어야 하기 때문에 상당히 오래 걸림
- UI를 개발하고 있다면 
	- 변경사항을 확인하기 위해서는 처음부터 컴파일을 해야됨
	- 따라서, 개발 중인 경우 더 치명적
	- 이럴 때 사용하는 것이 JIT
- Dart VM을 사용하여 작성한 코드를 바로 보여줌
	- 가상 머신에서 작동 중이라 조금 느림
	- 개발하는 중에 제공
	- 개발 주기는 빠르다.


### -> 개발 중에는 JIT 컴파일러 사용하고, 출시할 때는 AOT 컴파일을 함

### 즉, Dart는 매우 빠른 개발 주기(빠른 피드백)와 빠른 실행 및 시작 시간이라는 두 가지 이점을 모두 제공


> null safety

- 안전한 프로글매을 빌드할 때 아주 중요
- Java, C++ 등 많은 프로그래밍 언어에서 문제
- 개발자가 null 값을 참조하면 모든게 고장


> 핫 리로드

- Flutter는 개발 중 JIT 컴파일러를 사용해 일반적으로 1초 안에 코드를 다시 로드하고 계속 실행할 수 있음.
- 앱 상태는 가능할 때마다 리로드를 통해 유지되므로 앱이 중단된 시점부터 계속할 수 있음


> 초당 60 프레임의 훌륭한 애니메이션

- Flutter는 훌륭한 애니메이션을 쉽게 만들 수 있는데 Jank를 유발하는 일반적인 것들을 피할 수 있음

#### > **Jank**
- 일반적인 모바일 앱은 GUI를 가지며 항상 사용자와 상호작용 할 수 있어야 함
	- 만약 어떤 테스트 처리에 16ms 이상 소요되어 GUI 동작에 딜레이가 밠애하거나 멈추는 현상이 발생하면 이러한 현상을 **Jank**라고 한다.

- 60 fps 실행되는 Flutter의 UI는 아주 매끄럽게 보임
- ReactNative처럼 브릿지를 사용하지 않고 **직접 프레임워크 단에서 ui를 그리기 때문**에 다른 크로스 플랫폼보다 빠르다.


> 선제적 스케줄링, 타임 슬라이싱 및 공유 리소스

- Java, Kotlin, Object-C, Swift 등 여러 개의 동시 실행 스레드를 지원하는 대부분 프로그래밍 언어는 선점 기법 사용하여 스레드 간 전환을 수행

####  > **선점 기법**

- 각 스레드는 실행시간이 슬라이스로 할당되고 할당된 시간을 초과하면 다른 스레드로 넘어간다.
- 하지만 메모리와 같은 스레드 간에 공유되는 리소스를 업데이트할 때 선점이 발생하면 경쟁 조건이 발생
- 경쟁 조건은 앱 충돌 및 데이터 손실을 포함한 심각한 버그를 유발할 수 있다.
- 경쟁 조건을 해결하는 방법을 다른 스레드가 실행되지 않도록 Lock을 걸어 공유 리소스를 보호하는 것이다.
- 하지만 Lock은 더 심각한 교착상태를 유발할 수도 있다.

#### > **Dart는 여기서 다른 방식으로 접근**

- `isolates`라고 하는 다트의 스레드는 메모리를 공유하지 않으므로 Lock이 필요하지 않다.
- isolates는 **채널을 통해 메세지를 전달**해 통신한다.
- 즉, Dart는 기본적으로 단일 스레드에서 작동하므로 선점을 허용하지 않음
- 대신 스레드는 명시적으로 산출
	- `async/await`와 `Futures or Stream`을 사용한다. 
	- 개발자는 단일 스레딩을 통해 중요한 기능을 선점 없이 완료될 때까지 실행 가능


> Lock 없이 객체 할당 가비지 수집 가능

- 성능에 영향을 끼치는 중요한 원인 중 하나는 **가비지 컬렉션**

#### > 가비지 컬렉션

- 프로그래밍 개발 중 유효하지 않은 메모리인 **가비지(Garbage)**가 발생
- C언어를 사용하면 `free()`라는 함수를 통해 직접 메모리를 해제해 주어야 하지만 Java 등의 언어는 개발자가 직접 메모리를 해제해 주지 않아도 된다.
- **Why?**
	- **JVM**의 가비지 컬렉터가 불필요한 메모리를 알아서 정리해 주기 때문

- 가비지 콜렉션은 공유 리소스에 액세스하는 특별한 경우이며, 많은 언어에서 수행기간 동안 Lock을 사용해야 함
- Lock되어 사용 가능한 메모리가 수집되는 동안 전체 앱 실행이 중지될 수도 있다.
- **But,** Dart는 가비지 컬렉션을 Lock없이 수행 가능
	- `generational garbage collection and allocation scheme`를 사용하는데 **수명이 짧은 많은 객체들을 할당하는데 빠르다**.
	- https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30


> 선언적인 방식의 레이아웃

- Flutter는 명령적인 방식이 아닌 **선언적인 방식**으로 **UI를 작성**한다.
- Flutter는 JSX나 XML 같은 추가 템플릿이나 레이아웃과 언어 간에 레이아웃을 분할하지 않으며 **별도의 시각적인 레이아웃 도구가 필요하지 않다.**

#### > 선언형 vs 명령형

- **선언형 프로그래밍 (declarative programming)**
	- 순서나 문제 해결 과정을 다루기보다 무엇을 나타내야 할지에 초점
- **명령형 프로그래밍 (imperative programming)**
	- 언어 해석이 순차적이며 어떠한 방법으로 문제를 해결할지에 초점

- Flutter는 선언형 프로그래밍 방식을 사용하여 위젯을 변경해야 하는 상황이 생기면, 기존의 것을 변겅하는 것이 아닌 **지우고 새로 만든다.**

#### > 선언형의 장점

1. 가독성
2. 재사용성
3. 오류 복구: 특정 부분만 오류 체크를 할 수 있음
4. 참조 투명성: 다른 시스템에 영향을 주지 않음
5. 대체 가능성

