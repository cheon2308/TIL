
함수에 값을 전달 할 때 **값에 의한 호출(call by value)**와 **참조에 의한 호출(call by reference)** 두 가지가 있다.

> **매개변수**

-   매개변수(parameter)는 **함수에 전달되는 값**이자 **함수 괄호 안에 선언된 값**을 말한다.
-   쉼표로 각 매개변수를 다른 매개변수와 구분
-   아래는 n1, n2가 매개변수가 된다.

![](https://blog.kakaocdn.net/dn/ZGCyg/btr0Ht2IAUI/KRhZKy8bZV3v9refu2QQr0/img.png)

> **값에 의한 호출**

-   값에 의한 호출은 **매개변수의 복사본을 해당 함수 내부로 넘기는 방식**
-   복사본을 넘기는 것 뿐이기 때문에 함수 내부에서 이 복사본이 변경되더라도 **원본값은 변경되지 않는다.**
-   아래 코드의 경우 a를 넘겨 a+=10을 했지만 원본변수인 main() 함수의 a는 수정되지 않음

```cpp
#include <bits/stdc++.h>
using namespace std;
int add(int a, int b){
    a += 10;
    cout << a << '\n';
    return a + b;
}
int main(){
	int a = 1;
    int b = 2;
    int sum = add(a, b);
    cout << a << '\n';
    return 0;
}
```

-   vector를 값에 의한 호출을 하면 아래와 같이 된다. 
-   넘겨서 수정해도 아무런 반영이 되지 않음

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> v(3,0);
void go(vector<int> v){
	v[1] = 100;
}
int main(){
	go(v);
    for(int i : v) cout << i << '\n';
}
/*
0
0
0
*/
```

> **참조에 의한 호출**

-   참조에 의한 호출은 **원본변수의 주소를 매개변수로 함수에 전달**하는 방법
-   함수 내부에서 해당 매개변수를 변경하게 되면 **실제 원본변수에도 반영**이 된다.

아래 코드는 매개변수로 **&a**를 넘겼고 해당 함수에서 a를 수정했고 원본 변수에도 반영이 되었다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int add(int &a, int b){
	a += 10;
    cout << a << '\n';
    return a + b;
}
int main(){
	int a = 1;
    int b = 2;
    int sum = add(a,b);
    cout << a << '\n';
    return 0;
}
/*
11
11
*/
```

-   vector를 **참조에 의한 호출**을 하면 다음과 같이 된다.
-   넘겨서 수정했더니 원본 vector에 반영이 된다.

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> v(3, 0);
void go(vector<int> &v){
	v[1] = 100;
}
int main(){
    go(v);
    for(int i : v) cout << i << '\n';
}
/*
0
100
0
*/
```

> **Array의 요소 수정하기**

-   Array의 요소를 수정할 때는 아래처럼 크기를 정하지 않은 int a[], 또는 배열의 크기인 int a[3], 배열의 포인터인 int * a를 넘겨서 수정 가능

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[3] = {1, 2, 3};
void go(int a[]){
	a[2] = 100;
}
void go2(int a[3]){
	a[2] = 1000;
}
void go3(int *a){
	a[2] = 1000;
}
int main(){
    go(a); cout << a[2] << '\n';
    go2(a); cout << a[2] << '\n';
    go3(a); cout << a[2] << '\n';
}
/*
100
1000
1000
*/
```

> **2차원 배열 수정**

-   **vector**  
    -   2차원 vector의 경우 아래와 같이 수정
    -   총 3가지의 2차원 vector 선언 방법이 있는데 각 2차원 vector의 [0][0]에 0을 담고 수정하는 로직이 담겨 있는 코드

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<vector<int>> v;
vector<vector<int>> v2(10, vector<int>(10, 0));
vector<int> v3[10];
void go(vector<vector<int>> &v){
	v[0][0] = 100;
}
void go2(vector<vector<int>> &v){
	v[0][0] = 100;
}
void go3(vector<int> v[10]){
	v[0][0] = 100;
}
int main(){
    vector<int> temp;
    temp.push_back(0);
    v.push_back(temp);
    v3[0].push_back(0);
	
    go(v); go2(v2); go3(v3);
	cout << v[0][0] << " : " << v2[0][0] << " : " << v3[0][0] << '\n';
	return 0;
}
//100 : 100 : 100
```

-   **array**

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[3][3] = {{1, 2, 3}, {1, 2, 3}, {1, 2, 3}};
void go(int a[][3]){
	a[2][2] = 100;
}
void go2(int a[3][3]){
	a[2][2] = 1000;
}
int main(){
	go(a); cout << a[2][2] << '\n';
	go2(a); cout << a[2][2] << '\n';
}
/*
100
1000
*/
```