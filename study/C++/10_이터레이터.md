> **이터레이터**

-   **컨테이너에 저장되어 있는 요소**의 **주소를 가리키는 개체** 
-   **포인터를 일반화**
-   vector, map 등 각각 다르게 구현된 컨테이너들을 **일반화된 이터레이터를 통해 쉽게 순회** 가능

![](https://blog.kakaocdn.net/dn/mZBcM/btr0r60odEU/alEzXwe1DtWAQf8IiNKM3K/img.png)

-   바로는 주소값을 반환하지는 못하고 **&***를 통해 한단계 더 거쳐서 **가리키는 해당 요소의 주소값을 반환**할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> v;

int main(){
    for(int i = 1; i <= 5; i++)v.push_back(i);
    for(int i = 0; i < 5; i++){
    	cout << i << "번째 요소 : " << *(v.begin() + i) << "\n";
        cout << &*(v.begin() + i) << '\n';
    }
    for(auto it = v.begin(); it != v.end(); it++){
    	cout << *it << ' ';
    }
    cout << '\n';
    for(vector<int>::iterator it = v.begin(); it != v.end(); it++){
    	cout << *it << ' ';
    }
    auto it = v.begin();
    advance(it, 3);
    cout << '\n';
    cout << *it << '\n';
    
    // cout << v.begin() << '\n'; //에러
}

/*
0번째 요소 : 1
0x135e067f0
1번째 요소 : 2
0x135e067f4
2번째 요소 : 3
0x135e067f8
3번째 요소 : 4
0x135e067fc
4번째 요소 : 5
0x135e06800
1 2 3 4 5
1 2 3 4 5
4
*/
```

-   **vector<int>:: iterater**를 auto로도 선언할 수 있는 것을 알 수 있는데 vector<int>:: iterater가 **너무 길기 때문**에 간단하게 이터레이터를 선언하기 위해 **auto로 선언**한 것

> **이터레이터 함수**

1.  **begin()**  
    -   컨테이너의 시작 위치를 반환
2.  **end()**
    -   컨테이너의 끝 다음의 위치를 반환
    -   보통 it != v.end() 이런 식의 코드를 많이 볼 수 있는데
        -   컨테이너를 다 순회하고 컨테이너의 끝에 도착했다는 것
3.  **advance(iterator, cnt)**
    -   해당 iterator를 cnt까지 증가

**더 많은 함수 ->**

https://learn.microsoft.com/ko-kr/cpp/standard-library/iterator-functions?view=msvc-170