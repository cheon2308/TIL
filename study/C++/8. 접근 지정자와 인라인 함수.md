#### **황기태 저자의 **명품 C++ Programming 개정판을 읽고 학습한 내용을 정리한 포스트입니다!****

[https://search.shopping.naver.com/book/catalog/32436115747](https://search.shopping.naver.com/book/catalog/32436115747)

### **접근 지정자**

- OOP Language는 객체를 캡슐화하고, 외부에서 접근 가능한 **공개 멤버**와 외부의 접근을 허용하지 않는 **비공개 멤버**를 구분
- 아래와 같은 3가지 **멤버 접근 지정자(access specifier)**가 있다.
- **private(비공개)**  
    - 클래스 내의 멤버 함수들에게만 접근이 허용
- **public(공개)**
    - 클래스 내외를 막론하고 프로그램의 모든 함수들에게 허용
- **protected(보호)**
    - 클래스 내의 멤버 함수와 이 클래스를 상속받은 파생 클래스의 멤버 함수에게만 접근 허용
    - 나중에 상속 다루면서 다시 설명
- 접근 지정자는 **여러 번 사용 가능**하며, 다른 접근 지정자가 선언될 때까지 모든 멤버에 대해 적용

> **디폴트 접근 지정은 private**

- 접근 지정을 하지 않은 경우 **디폴트 접근 지정**은 **private**로 처리
- => 캡슐화의 기본 원칙이 비공개 이기 때문
- 따라서, **멤버 변수는** private로 지정 후 **클래스의 생성자**를 통해 멤버 변수에 접근 하는 것이 바람직 하다.
- 또한, **생성자는 public**으로 저장해야 main 문에서 호출할 수 있다.
    - 다만, 의도적으로 외부에서 객체 생성을 금지하지 위한 private
    - 자식 클래스에서만 생성자 호출 되도록하는 protected도 사용함

---

### **인라인 함수**

> **함수 호출에 따른 시간 오버헤드**

- 초기 => 함수는 **적절한 단위 작업**을 하나의 함수로 작성하여 사용 => 프로그램을 구성하는 빌딩 블록의 역할
- 그러나 함수의 호출에는 아래와 같이 시간 소모라는 대가가 따른다.

![](https://blog.kakaocdn.net/dn/brE8JI/btsBbQGTtK3/9jFlyGqnIk9k5zeOXiqE71/img.png)

함수 호출에 따른 시간 오버헤드

- 함수 호출 오버헤드는 시간이 무시할 수 없는 비중을 하지하는 경우도 있다.
- 따라서, 짧은 코드라도 함수를 자주 호출하게 되면 실행 시간이 길어지는 원인이 되므로, 짧은 코드에서, 함수 호출 오버헤드를 줄인다면 **실행속도를 개선할 수** 있을 것이다.

> **인라인 함수**

- 짧은 코드로 구성된 함수에 대해, 함수 호출 오버헤드로 인한 프로그램의 실행 속도 저하를 막기 위해 도입된 기능
- **inline 키워드를 이용하여 선언 가능**

```cpp
inline int odd(int x) {
    return (x%2);
}
```

- 컴파일러는 함수를 호출하는 곳에 인라인 함수의 코드를 그대로 삽입 => 함수 호출 xx => **실행 속도가 빨라진다.**
- c++에는 멤버 변수에 값을 쓰는 **getter/setter**와 같은 작은 함수를 많이 사용 => 자주 호출 되는 작은 함수들을 **인라인 함수로 선언**한다면 **프로그램의 실행 속도를 향상**시킬 수 있음.
- 하지만, 호출하는 곳이 여러 군데 있으면 그 만큼 전체 크기가 늘어나는 **단점**이 있따. => **code segment 크기 증가**, **성능은 향상되지만, 메모리를 더 많이 잡아먹는 오버헤드가 존재** 
- **제약 사항**  
    - inline 선언은 컴파일러에게 주는 일종의 **요청 =>** **강제 명령 xxx**
    - 따라서, 컴파일러에 따라 재귀 함수(recursion), static 변수, 반복문, switch 문 등을 가진 함수 => 특히 긴 함수를 인라인화한다면 무시될 가능성이 있다.