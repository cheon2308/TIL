
함수와 자료구조는 엮여있는게 많다. 따라서, **자료구조**에서 모르는 것이 있다면 찾아보면서 공부해보자. 주로 코딩테스트에 자주 나오는 함수들을 위주로 알아보자.

---

### **1. fill()과 memset()**

두 함수 모두 **배열을 초기화** 할 때 사용한다.

> **fill()**

-   **O(n)의 시간복잡도**를 가지며 **fill(시작값, 끝값, 초기화하는값)**로 값을 초기화한다.
-   **모든 값을 기반으로 초기화가 가능**하다.

```cpp
void fill (ForwardIterator first, ForwardIterator last, const T& val);
```

-   fill()로 배열의 값을 초기화한다고 했을 때 배열의 모든 값이 아닌 일부값을 초기화하는 경우도 있지만 **보통은 전체를 초기화**한다.

```cpp
#include <bits/stdc++.h>
using namespace std;

// 배열의 크기를 정할 때 const int로 하면 실수 방지 가능
// 어떤 순간에는 1004, 1000 이렇게 사용자의 실수를 방지함.
const int max_n = 1004;
// 초기화 값이 길 경우, const로 선언해 놓는게 좋다.
const int INF = 987654321;

// vector 10개를 생성
vectoer<int> v[10];
// 초기값이 0인 vector 1개를 생성
vectoer<int> v2(10, 0);
// 크기 10 * 10, 초기값은 0인 2차원 vector 생성
vector <vector<int> > v3(10, vector<int>(10, 0));
// 크기가 정해지지 않은 2차원 vector 생성
vector<vector<int> > v4;

// 1차원 배열을 만들어서 0으로 초기화하는 방법
// 일부 컴파일러에서 통하지 않을 수도 있으니 사용 안하는 것이 좋음

int dp[10] = {0,};

// 1차원 배열 a, 2차원 배열 a2
int a[max_n];
int a2[max_n][max_n];
int main() {
	// 이터레이터 기반으로 초기화
    fill(v2.begin(), v2.end(), INF);
    // 10으로 초기화, 1004까지 전체적으로 초기화 한다.
    fill(a, a + max_n, 10);
    // fill을 이용한 2차원 배열 초기화 방법 1
    for(int i = 0; i < max_n; i++) fill(a2[i], a2[i] + max_n, INF);
    // fill을 이용한 2차원 배열 초기화 방법 2 <- 이걸 추천함
    fill(&a2[0][0], &a2[0][0] + max_n * max_n, INF);
    return 0;
    
}
```

> **memset()**

-   바이트단위로 **초기화**를 하며 **0, -1, char형의 하나의 문자(a, b, c, 등..)으로 초기화**를 할 때만 사용

```cpp
void * memset ( void * ptr, int value, size_t num);
```

-   **memset( 배열의 이름, k, 배열의 크기 )** 이렇게 사용한다.

```cpp
#include <bits/stdc++.h>
using namespace std;
const int max_n = 1004;
int a[max_n];
int a2[max_n][max_n];
int main(){
    memset(a, -1, sizeof(a));
    memset(a2, 0, sizeof(a2));
    for(int i = 0; i < 10; i++) cout << a[i] << " ";
    return 0;
}
//-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 %
```

코드를 보면 알 수 있듯이 **fill 보다는 간편하게 초기화**하는 것을 볼 수 있다.

따라서 0 또는 -1이란 값으로 초기화할 때는 memset을 쓰는 것이 좋다.

단 ! 1 또는 10 이런 숫자는 절대 **memset()으로 초기화 불가능**이므로 조심!

---

### **2. memcpy()**

-   어떤 변수의 메모리에 있는 값들을 다른 변수의 "**특정 메모리값"**으로 복사할 때 사용
-   주로 배열ㅇ르 **깊은 복사**할 때 사용

```cpp
void * memcpy ( void * destination, const void * source, size_t num);
```

-   예를 들어 a라는 **원본배열이 수정되는 로직**이 있는데, 그 다음 이 **원본 배열이 수정되지 않은 상태값을 기반**으로 또 다른 로직이 필요하다고 하자.
-   즉, **깊은 복사**가 필요하므로 **memcpy()** 사용 (다른 이유로도 많이 사용한다)
-   아래 코드에서는 temp라는 배열에 a를 담아두고 a를 수정하는 로직을 구현한 뒤 a라는 배열에 다시 예전 온전한 a를 담음 temp를 이용해 다시 a를 만드는 코드이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[5], temp[5];
int main(){
    for(int i = 0; i < 5; i++)a[i] = i;
    memcpy(temp, a, sizeof(a));
    for(int i : temp) cout << i << ' ';
    cout << '\n';
    // 원본 배열 a를 수정하여 출력하는 로직
    // a를 수정해서 ~~를 더하는 로직이 될 수 있다.
    a[4] = 1000;
    for(int i : a) cout << i << ' ';
    cout << '\n';
    // 그 다음 다시 temp를 기반으로 원본배열을 담아 둠.
    memcpy(a, temp, sizeof(temp));
    for(int i : a) cout << i << ' ';
    cout << '\n';
    return 0;
}
/*
0 1 2 3 4
0 1 2 3 1000
0 1 2 3 4
*/
```

---

### **3. sort()**

-   sort()는 배열 등 **컨테이너들의 요소를 정렬**하는 함수
-   보통 **array나 vector를 정렬**할 때 쓰이며 **O(nlogn)**의 **시간복잡도**
-   sort()에 들어가는 **매개변수로는 3가지**가 있으며 2개는 반드시 넣어야 하며 한개는 선택

```cpp
sort(first, last, *커스텀비교함수)
```

-   **first**는 정렬하고 싶은 배열의 첫번째 이터레이터
-   **last**는 정렬하고 싶은 배열의 마지막 이터레이터  
    -   따라서 [first, last) 라는 범위를 가진다.
    -   즉, **first는 포함, last는 포함하지 않는다.**
    -   크기가 5인 a라는 배열 전체를 sort한다고 하면 sort(a[0], a[0] +5)라고 해야한다.
-   **3번째 인자 -> 커스텀비교함수(선택)**
    -   sort에 커스텀비교함수를 넣지 않으면 **기본적으로 오름차순**
    -   3번재 인자에 **greater<int>()** 를 넣어 **내림차순 등**으로 변경하수 있다.
    -   참고로 **less<int>()**을 통해 오름차순 정렬 가능

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> a;
int b[5];
int main(){
    for(int i = 5; i >= 1; i--) b[i-1] = i;
    for(int i = 5; i >= 1; i--) a.push_back(i);
    // 오름차순
    sort(b, b+5);
    sort(a.begin(), a.end());
    for(int i : b) cout << i << ' ';
    cout << '\n';
    
    for(int i : a) cout << i << ' ';
    cout << '\n';
    
    sort(b, b+5, less<int>());
    sort(a.begin(), a.end(), less<int>());
    for(int i : b) cout << i << ' ';
    cout << '\n';
    for(int i : a) cout << i << ' ';
    cout << '\n';
    
    // 내림차순
    sort(b, b+5, greater<int>());
    sort(a.begin(), a.end(), greater<int>());
    for(int i : b) cout << i << ' ' ;
    cout << '\n';
    for(int i : a) cout << i << ' ';
    cout << '\n';
    
    return 0;
}

/*
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
5 4 3 2 1
5 4 3 2 1
*/
```

-   또한 pair를 기반으로 만들어진 vector의 경우 따로 설정하지 않으면 **first, second, third 순으로 차례차례 오름차순 정렬**

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<pair<int, int>> v;
int main(){
    for(int i = 10; i >= 1; i--){
        v.push_back({i, 10 - i });
    }
    sort(v.begin(), v.end());
    for(auto it : v) cout << it.first << " : " << it.second << "\n";
        return 0;
}

/*
1 : 9
2 : 8
3 : 7
4 : 6
5 : 5
6 : 4
7 : 3
8 : 2
9 : 1
10 : 0
*/
```

-   위 코드를 보면 오름차순 정렬된 것을 볼 수 있다.  
-   **아래 두 코드는 동일**
    -   vector v에 있는 **"요소"**들을 끄집어내서 순회한다는 의미
    -   v[0], v[1] 따위로 접근한다는 의미

```cpp
for(auto it : v) cout << it.first <<  " : " << it.second << "\n";
```

```cpp
for(pair<int, int> it : v
```

-   **내림차순** 정렬을 하기 위해서는 어떻게 해야될까? 또 first는 내림차순, second는 오름차순 정렬을 하고 싶다면?
-   이 때, 커스텀 연산자를 만들면 된다.

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<pair<int, int>> v;
bool cmp(pair<int, int> a, pair<int, int> b){
	return a.first > b.first;
}
int main(){
	for(int i = 10; i >= 1; i--){
    	v.push_back({i, 10 - i});
    }
    sort(v.begin(), v.end(), cmp);
    for(auto it : v) cout << it.first << " : " << it.second << "\n";
    	return 0;
}
/*
10 : 0
9 : 1
8 : 2
7 : 3
6 : 4
5 : 5
4 : 6
3 : 7
2 : 8
1 : 9
*/
```

---

### **4. unique()**

-   범위안의 있는 요소 중 **중복되는 요소를 제거**하고 **중복되지 않은 요소들로 앞에서부터 정렬**되어 채운다.
-   그리고 나서 나머지 요소들은 **삭제하지 않고 그대로 두는 함수**
-   **unique 함수의 반환 값은 중복없이 나열된 마지막 원소 다음의 반복자다.**
-   **알고리즘 헤더에 존재**
-   **O(n)의 시간복잡도**

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> v;
int main() {
	for(int i = 1; i <= 5; i++){
    	v.push_back(i);
        v.push_back(i);
    }
    for(int i : v) cout << i << " ";
    cout << '\n';
    // 중복되지 않은 요소로 채운 후, 그 다음 이터레이터를 반환한다.
    auto it = unique(v.begin(), v.end());
    cout << it - v.begin() << '\n';
    // 앞에서부터 중복되지 않게 채운 후 나머지 요소들은 그대로 둔다.
    for(int i : v) cout << i << " ";
    cout << '\n';
    return 0;
} 

/*
1 1 2 2 3 3 4 4 5 5
5
1 2 3 4 5 3 4 4 5 5
*/
```

-   따라서, unique()를 통해 중복되지 않은 요소들의 집합을 만들고 싶다면 아래 코드 처럼 구축하면 된다.
-   아래에서 unique(v.begin(), v.end())가 반환하는 값은 1 2 3 4 5 2 2 중복없이 나열된 마지막 원소 다음의 반복자 위치이다.
-   **sort(), erase(), unique() 순**

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> v;
int main() {
	for(int i = 1; i <= 4; i++ {
    	v.push_back(i);
        v.push_back(i);
    }
    for(int i = 5; i >= 1; i--){
    	v.push_back(i);
        v.push_back(i);
    }
    sort(v.begin(), v.end());
    for(int i : v) cout << i << " ";
    cout << '\n';
    v.erase(unique(v.begin(), v.end()), v.end());
    for(int i : v) cout << i << " ";
    return 0;
}

// 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5
// 1 2 3 4 5
```

---

### **5. lower_bound()와 upper_bound()**

-   정렬된 배열에서 어떤 값이 나오는 지점이나 어떤 값이 나오기전의 위치를 반환하려면?
-   이분탐색을 쉽게 함수로 구현하려면?
-   이를 위해 쉬운 함수인 **lower_bound()**와 **upper_bound()**를 알아보자.

![](https://blog.kakaocdn.net/dn/tSN9N/btr0rhBC6gL/tjh7BNkWbHHpdG7spnMAHk/img.png)

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
int main(){
    vector<int> v;
    int a[5] = {1, 2, 2, 2, 3};
    for(int i = 0; i < 5; i++){
    	v.push_back(a[i]);
    }
    int x = 2;
    int c = (int)(upper_bound(v.begin(),v.end(),x) -
    lower_bound(v.begin(),v.end(),x));
    int f = (int)(lower_bound(v.begin(),v.end(),x) - v.begin());
    int t = (int)(upper_bound(v.begin(),v.end(),x) - v.begin());
    int f2 = *lower_bound(v.begin(),v.end(),x);
    int t2 = *upper_bound(v.begin(),v.end(),x);
    printf("%d의 갯수 : %d, 시작되는 점 : %d 끝나는 점 : %d\n", x,
    c, f, t);
    printf("lower bound가 시작되는 점의 값 : %d, upper bound가
    시작되는 점의 값 : %d\n", f2, t2);
    c = (int)(upper_bound(a, a + 5, x) - lower_bound(a, a + 5,
    x));
    f = (int)(lower_bound(a, a + 5, x) - a);
    t = (int)(upper_bound(a, a + 5, x) - a);
    f2 = *lower_bound(a, a + 5, x);
    t2 = *upper_bound(a, a + 5, x);
    printf("%d의 갯수 : %d, 시작되는 점 : %d 끝나는 점 : %d\n", x,
    c, f, t);
    printf("lower bound가 시작되는 점의 값 : %d, upper bound가
    시작되는 점의 값 : %d\n", f2, t2);
    return 0;
}
/*
2의 갯수 : 3, 시작되는 점 : 1 끝나는 점 : 4
lower bound가 시작되는 점의 값 : 2, upper bound가 시작되는 점의 값 :
3
2의 갯수 : 3, 시작되는 점 : 1 끝나는 점 : 4
lower bound가 시작되는 점의 값 : 2, upper bound가 시작되는 점의 값 :
3
*/
```

-   위의 코드처럼 **lower_bound**는 0번째 배열의 원소부터 찾아서 어떠한 값의 "**이상이 되는 위치**"를 반환
-   "upper_bound"는 그 값이 시작되기 전의 위치를 반환
-   **O(nlong)의 시간복잡도**
    -   1, 2, 2, 3, 4 배열에서 2를 찾는다면 3의 위치를 반환
    -   4를 찾는다면 그 전 값인 5번째 요소를 반환
    -   이 때 **반환되는 값은 이터레이터** 이기 때문에 **배열의 처음 주소값인 v.begin()** 또는 **a[0]**, 을 빼주어서 **int형으로 몇번째인지 파악 가능**하다.
    -   또한 반환되는 것은 **주소값이 반환**되기 대문에 그 주소값이 몇번째임을 알려면 주소값의 첫번째 값을 빼주면 된다.

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main(){
    vector<int> a;
    for(int i =1 ; i<= 3; i++)a.push_back(i);
    for(int i =5 ; i<= 10; i++)a.push_back(i);
    cout << lower_bound(a.begin(), a.end(), 4) - a.begin() << "\n"; // 3
    return 0;
}
```

-   만약 원소를 찾을 때 못 찾을 경우 아래 코드와 같이 반호나하게 된다.
-   값이 없다면 근방지점을 반환해준다.
-   **이분 탐색을 배울 때 이분탐색의 결과도 이와 비슷하게 출력**

```cpp
#include <bits/stdc++.h>

using namespace std;
vector<int> v;
int main(){
    for(int i = 2; i <= 5; i++)v.push_back(i);
    v.push_back(7);
    // 2 3 4 5 7
    cout << upper_bound(v.begin(), v.end(), 6) - v.begin() << "\n";
    cout << lower_bound(v.begin(), v.end(), 6) - v.begin() << "\n";
    cout << upper_bound(v.begin(), v.end(), 9) - v.begin() << "\n";
    cout << lower_bound(v.begin(), v.end(), 9) - v.begin() << "\n";
    cout << upper_bound(v.begin(), v.end(), 0) - v.begin() << "\n";
    cout << lower_bound(v.begin(), v.end(), 0) - v.begin() << "\n";
/*
4
4
5
5
0
0
*/
}
```