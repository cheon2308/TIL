
> **비트(bit)**

-   컴퓨터에서는 연산을 수행하기 위해 **비트**를 사용한다.
-   1bit = 0 또는 1
-   8bits = 1byte

> **비트 연산자**

-   아래 6가지 비트 연산자

![](https://blog.kakaocdn.net/dn/pwEuO/btr0HSgSyK8/0kRjLwqa0vG3Q9EpaErLok/img.png)

-   **주의할 점**  
    -   비트 연산의 우선순위에 주의할 필요가 있다
    -   일반적 사칙연산은 **비교 , 논리 연산자(==, >, && 등)**보다 **우선순위**가 높다.
    -   하지만, **비트 연산**은 **논리연산보다 우선순위가 높으나 비교 연산보다는 낮다**.
    -   따라서 아래 코드는 주의가 필요

```cpp
if (x & y == 0) // if (x&(y==0)) 과 같음!!
```


> **비트 연산 응용**

-   **& AND, | OR**  
    -   비트 집합 두개를 **AND**하면 **교집합**, **OR**하면 **합집합**을 구할 수 있다.
-   **^ XOR**  
    -   true / false를 번갈아 바꾸는 **스위치**를 구현 가능
    -   어떤 수에서 몇 개의 bit를 바꿔서 대응되는 수를 구할 수 있음
    -   대표적인 예 -> **ASCIII** 코드
        -   **짝이 맞는 문자끼리 다른 bit를 XOR 시키는 기법**을 이용한 대소문자 변환 함수
    -   같은 값끼리 XOR 하면 0이되는 특징은 많은 곳에 적용 가능
    -   각 변이 X축 또는 Y축에 평행한 직사각형이 있을 때 세 꼭지점의 좌표가 주어질 때 남은 한 꼭지점의 좌표를 구할 수 있다.
    -   (**x0 ^ x1 ^ x2, y0 ^ y1 ^ y2)**
    -   SWAP을 아래와 같은 코드로 구현할 수 있지만
        -   **XOR SWAP은 임시 변수를 만들어 바꾸는 SWAP보다 효과적이지 않고, 두 포인터가 같은 곳을 가리킬 때 제대로 동작하지 않으므로 권장 xxxx**

```cpp
// WARNING 권장되지 않는 코드
void xor_swap(int* x, int* y) {
    *x ^= *y;
    *y ^= *x;
    *x ^= *y;
}
```

```
// ASCII 코드 변환

char case_convert(char alphabet){
	return alphabet ^ 32;
}
```

-   **~ NOT**  
    -   비트 집합에 사용하면 가지고 있지 않은 원소들을 구할 수 있다.
    -   음의 인덱스로 사용 가능

```cpp
// 앞에서부터 i번째 원소와 뒤에서부터 i번째 원소를 출력하는 코드
std::vector<int> vec{0,1,2,3,4};
for(size_ti = 0; i < vec.size(); ++i){
	printf("%d %d\n", vec.begin[i], vec.end()[~i]);
}
```

-   **<<, >> shift**  
    -   2의 거듭제곱 곱셈/나눗셈
    -   정수 자료형을 왼쪽으로 i 칸 밀거나 오른쪽으로 i 칸 미는 연산은 각각 2^i 를 곱하거나 2^i 로 나누는 연산과 동일
    -   특히 / 연산은 느리므로 나누는 수가 2의 거듭제곱일 경우 >> 로 변경시 성능 향상 얻을 수 있음
    -   마찬가지고 % 연산도 나누는 수가 2의 제곱수일 경우 &로 바꿀 수 있음
    -   **1 << n**  
        -   2^n 값을 가지며 원소가 n개일 경우의 모든 **부분집합의 수**를 의미
        -   **power set(모든 부분 집합)**
            -   공집합과 자기 자신을 포함한 모든 부분 집합
            -   각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산
    -   **i & (1 << j)**
        -   계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미

```cpp
// WARNING 음수일 때 제대로 동작하지 않음
void div(int num, int x){
	printf("%d / 2^%d = %d ... %d\n", num, x, num >> x, num & ((1<<x) -1));
}
```

> **비트 마스킹**

-   각 Bit를 하나의 Flag로 활용한다면 자료 저장과 집합 표현을 쉽게 할 수 있다.
-   사람에 0~31 사이의 번호가 매겨져 있고, 사람 A 의 친구 목록이 {0, 3, 6, 7, 10, 13, 28}이고, B 의 친구 목록이 {0, 1, 4, 5, 6, 17, 21, 28} 이라고 하자.
-   이 때 아래와 같은 문제를 풀어보자.
    1.  A, B 모두와 친구인 사람은?
    2.  A 또는 B 와 친구인 사람은?
-   반복문 대신 **비트를 사용**하면 "**집합"**연산이 간단해진다.
-   친구 목록을 사람 번호로 저장하지 않고 x번째 사람이 내친구라면, x 번째 비트를 1로 표시하는 방식으로 바꾸자.

![](https://blog.kakaocdn.net/dn/cu4Liv/btr0NIqLmA9/kgp78ASAUrhsfklqykttK0/img.png)

1번 문제 -> **&를 이용하여 해결**

2번 문제 -> **| 를 연산하여 구할 수 있음**

> **데이터 압축**

-   문자열 두 개를 비교하는 데에는 **O(문자열의 길이)**의 시간이 든다.
-   만약 사용하는 문자의 가짓수가 적다면 필요한 bit만 골라서 정수형 자료형에 압축 가능
-   예 -> 문자열이 알파벳 대문자로만 이루어져 있다면 알파벳끼리 구분하는 데 1 이상 26 이하의 값만 필요
    -   **5bit****s 만으로 표현 가능**

![](https://blog.kakaocdn.net/dn/btgyiy/btr0RKaJF3H/BgKgfEoA6trviZWaaBsjek/img.png)

아렇게 압축된 정수의 대소 비교 결과는 원래 문자열의 사전순 비교 결과와 같음

실제고 Pro 시험에는 이런 작은 길이의 문자열을 다루는 문제가 많고, 압축 기법은 굉장히 많이 사용된다.

```
// 12자 이내의 알파벳 대문자 문자열을 하나의 long long 변수에 압축
// WARNING 문자열의 끝('\0') 이후에도 전부 '\0'으로 채워져 있어야 됨
long long compress(char str[13]){
	long long res = 0;
    for(size_ti = 0; i < 12; ++i){
    	res = (res << 5) | (str[i] ^ 64);
    }
    return res;
}
```