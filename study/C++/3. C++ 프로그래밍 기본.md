#### **황기태 저자의 **명품 C++ Programming 개정판을 읽고 학습한 내용을 정리한 포스트입니다!****

[https://search.shopping.naver.com/book/catalog/32436115747](https://search.shopping.naver.com/book/catalog/32436115747)

```c++
/*
    C++ 프로그래밍 기본
    cout 으로 출력하기
*/

#include <iostream> // cout과 << 연산자 포함

// c++ 프로그램은 main() 함수에서부터 실행을 시작한다.
int main() {
    std::cout << "hELLO\n";
    std::cout << "2번째 줄";
    return 0; // main 함수가 종료하면 프로그램이 종료됨
}

/*
    실행결과
    hELLO
    2번째줄
*/
```

위의 예제를 바탕으로 기초적인 부분을 살펴보자

#### **주석**

- 실행에 영향 xx 
- 한 줄 주석 => **// 내용입력**
- 여러 줄 주석 => **/* 내용 입력 */**

---

#### **main() 함수**

- c++ 프로그램의 **시작점**이므로, 반드시 하나의 **main()** 함수가 존재해야 하며, 종료시 프로그램이 종료된다.
- c++ 표준 리턴타입 = **int** 이고 void는 표준이 아니다.
- **main** **함수**는 예외적으로 return 문을 **생략 가능**

---

#### **#include <iostream>

- **전처리기(C++ Preprocessor)**에 대한 지시문
- 소스 파일을 컴파일하기 전, <iostream> 헤더 파일을 읽어 c++ 소스 파일 안에 삽입할 것을 지시
- **iostream 헤더** **파일**에는 C++ 표준 입출력을 위한 클래스와 객체가 선언되어 있음 => 키보드 입력이나 화면 출력을 위해 꼭 필요

---

#### **화면 출력**

- **cout 객체**
    - c++ 표준 출력 스트림 객체(standard output stream object)
    - c++ 프로그램에서 출력한 데이터를 자신과 연결된 스크린에 대신 출력해준다. (std 접두어 => cout의 이름 공간이 std임을 표시)
- **<< 연산자**
    - 스트림 삽입 연산자(stream insertion operator)로 불리며, **오른쪽 피연산자 데이터를 왼쪽 스트림 객체에 삽입**
    - 본래는 **정수를 왼쪽으로 쉬프트하는 기본 연산자**이지만, 출력 스트림에 데이터를 삽입하는 삽입 연산자로 **<iostream****>** 헤더 파일에 '**연산자 오버로딩'**되어 cout과 함께 사용

---

#### **화면에서 다음 줄로 넘어가기**

1. **\n**  
    - << 연산자가 \n 문자를 cout의 스트림 버퍼에 단순히 삽입하고 끝난다.
    - 이후 cout 스트림 버퍼가 꽉 차거나 강제 출력 지시가 있는 경우, cout은 \n을 **해석**하여 커서를 다음 줄로 넘김
2. **endl()**
    - **<iostream> 헤더 파일**에 작성되어 있는 함수
    - std::cout << std::endl;이 실행되면 << 연산자가 endl() 함수를 호출
    - endl() 함수는 \n을 cout의 스트림 버퍼에 넣고, cout에게 현재 스트림 버퍼에 있는 데이터를 즉각 장치에 출력하도록 지시
    - 즉, **endl을 사용**하면 **커서를 다음 줄로 넘기는 것과 동시에 현재 cout의 스트림 버퍼에 있는 모든 데이터를 출력 => 버퍼를 비운다.**

**시간적 측면**에서 보면 버퍼를 비우지 않는 \n이 유리하지만 상황에 따라 잘 사용해야 한다.

---

#### **이름 공간(namespace와 std::)**

- 프로젝트를 여러 명이 나누어 개발하거나, 다른 사람이 작성한 소스 코드나 목적 파일을 가져와서 하용하는 경우 **identifier(이름)**이 충돌하는 경우가 있다.
    - 프로젝트를 여러 명이 나누어 개발하는 경우, 한 개발자가 **작성한 클래스, 상수, 변수, 함수의 "이름"이 같은 팀의 다른 개발자가 작성한 이름과 동일하면, 함께 컴파일하거나 링크할 때 오류가 발생**할 수 있고, 이를 수정하는데 상당한 시간과 노력이 든다.  
        
    - 또는 **오픈 소스를 가져와 개발자가 작성한 프로그램과 함께 컴파일 하는 경우에도 이름 충돌의 문제가 발생**한다.
- c++ 표준에서는 개발자가 자신만의 고유한 이름 공간을 생성할 수 있도록 **namespace 키워드** 도입 => 서로 다른 이름 공간 안에 선언된 이름들은 **별개의 이름으로 취급**되는 것

```cpp
// A.h
...
namespace A{
	int f();
    void m();
}
...

// A.cpp
#include "B.h"

namespace A{
	int f(){
    	return 1;
    }
    
    void m(){
    	f();	// A.cpp에 구현된 f() 함수
        B::f();	// B.cpp에 구현된 f() 함수
    }
}
// B.h
...
namespace B{
    int f();
    int g();
}
...

// B.cpp
namespace B{
	inf f(){
    	return -1;
    }
    
    int g(){
    	return 0;
    }
}
```

- 위와 같이 **namespace 키워드**를 사용하여 자신만의 공간을 만들 수 있다.
- 함수 f()의 충돌을 방지하기 위해 각 이름 공간에서 선언해주었고, **B::f()**를 통해 A공간에서 B공간의 f() 함수를 호출한다.

---

#### **std::와 using 지시어**

- std는 C++ **표준 이름 공간**
- 따라서, 표준 라이브러리에서 선언된 이름을 사용시 **std::**를 붙여야됨.
- 매번 std::를 붙이기 번거롭기에 **using 지시어**를 사용하여 생략할 수 있다.

```
using namespace std;

using namespace std::cout;
```

- std::cout만 생략할 수도, std 이름 공간에 선언된 모든 이름을 생략할 수도 있다.

---

#### **키 입력 받기**

- **cin 객체**
    - c++ 표준 입력 스트림 객체이므로 #include <iostream> 작성 필수
    - 모든 기본 타입에 대해  >> 연산자로 데이터 입력이 가능 => **c언어와는 달리 주소 값이 아닌 변수 이름 그대로 받아야됨** 
- **>> 연산자**  
    - 스트림 추출 연산자
    - 왼쪽 피연산자인 스트림 객체로부터 데이터를 읽어 오른쪽 피연산자에 삽입
    - << 연산자와 마찬가지로 **연산자 오버로딩**

---

#### **실행문 중간에 변수 선언**

- c와 마찬가지로 c++에서도 **프로그램 어디서나 변수 선언**이 가능하며 몇 가지 장점이 존재
    1. 변수를 사용하는 코드 바로 위에 선언 => **가독성이 좋아진다.**
    2. 변수를 사용하기 바로 전 라인에 변수를 선언하면, 변수 이름을 잘못 타이핑하는 실수를 줄일 수 있음
    3. for 문과 같이 필요한 곳에 변수(int n)을 선언하여 사용가능

```
for (int n=0; n<10; n++)
    cout << n;
```

- 다만 선언된 변수들이 코드 사이에 흩어져 있어, **선언된 변수를 한 눈에 보기 힘들고, 코드 사이에서 선언된 변수를 찾기가 용이하지 않다는** 단점도 존재한다.

**현재 책에서는 기본적인 연산, 변수 선언 방법, 함수, 조건문 등에 대해 다루지 않지만 홈페이지에 가면 기초를 볼 수 있다.**

**따라서, 기초적인 문법에 관한 부분은 구글에 검색해서 찾아보는 것을 추천합니다..!**